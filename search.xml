<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用容器配置mysql主从实现读写分离]]></title>
    <url>%2F2018%2F05%2F24%2F%E7%94%A8%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AEmysql%E4%B8%BB%E4%BB%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[容器简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。 CentOS 7 安装docker安装必要的一些系统工具 1$ yum update 1$ yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息 1$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新并安装 Docker 1234567$ yum makecache fast$ yum -y install docker-ce$ echo 开启容器服务$ systemctl enable docker$ systemctl start docker 注意： 123456789101112131415$ 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。$ vim /etc/yum.repos.d/docker-ce.repo$ 将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1$ $ 安装指定版本的Docker-CE:$ Step 1: 查找Docker-CE的版本:$ yum list docker-ce.x86_64 --showduplicates | sort -r$ Loading mirror speeds from cached hostfile$ Loaded plugins: branch, fastestmirror, langpacks$ docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable$ docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable$ docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable$ Available Packages$ Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)$ yum -y install docker-ce-[VERSION] 注册一个阿里的账号,进入加速器页面https://cr.console.aliyun.com/#/accelerator 1$ vim /etc/docker/daemon.json 内容如下 123&#123;"registry-mirrors": ["https://你的阿里云加速地址.mirror.aliyuncs.com"]&#125; 重启docker 12$ systemctl daemon-reload$ systemctl restart docker 常用docker命令查看运行容器 1$ docker ps 查看所有容器 1$ docker ps -a 进入容器其中字符串为容器ID: 1$ docker exec -it d27bd3008ad9 /bin/bash 1.停用全部运行中的容器: 1$ docker stop $(docker ps -q) 2.删除全部容器： 1$ docker rm $(docker ps -aq) 3.一条命令实现停用并删除容器： 1$ docker stop $(docker ps -q) &amp;&amp; docker rm $(docker ps -aq) 安装mariadbcentOS上比yum安装mysql要方便. ###安装mysql-client，用于访问mysql容器数据库 1$ yum -y install mariadb 单独MySQL模式1234567docker run -d \-e TIMEZONE=Asia/Shanghai \-v /data/mariadb-master:/data/mariadb \-e MYSQL_ROOT_PASSWORD=admin \-e REPLICATION_PASSWORD=admin \-p 3306:3306 \mariadb MariaDB MASTER进入容器需要修改镜像将下面内容添加进/etc/mysql/conf.d/*.cnf从机server-id=2 12345[mysqld]server-id=1log-bin=mysql-binbinlog_format=MIXEDdefault-time_zone = '+8:00' 提交 12docker commit -m "set log bin on" -a "lional" d27bd3008ad9 mariadb-master:1.0docker commit -m "set log bin on" -a "lional" d27bd3008ad9 mariadb-slave:1.0 运行master, 这里LOG_BIN参数没有用,所以在上面修改了镜像 1234567891011docker run -d \--restart=always \--name mysql-master \-e TIMEZONE=Asia/Shanghai \-v /data/mariadb-master:/data/mariadb \-e MYSQL_ROOT_PASSWORD=admin \-e LOG_BIN=mysql-bin \-e BINLOG_FORMAT=MIXED \-e REPLICATION_PASSWORD=admin \-p 3306:3306 \mariadb-master:1.0 查询容器的ip地址 1$ docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' $(docker ps -a -q) 1172.17.0.2 链接容器mysql 1mysql -uroot -padmin -h 172.17.0.2 查看master是否启用了log_bin 123456789101112MariaDB [(none)]&gt; show variables like '%log_bin%';+---------------------------------+--------------------------------+| Variable_name | Value |+---------------------------------+--------------------------------+| log_bin | ON || log_bin_basename | /var/lib/mysql/mysql-bin || log_bin_compress | OFF || log_bin_compress_min_len | 256 || log_bin_index | /var/lib/mysql/mysql-bin.index || log_bin_trust_function_creators | OFF || sql_log_bin | ON |+---------------------------------+--------------------------------+ 查看主机状态,注意启动从机的时候bin和pos的参数 123456MariaDB [(none)]&gt; show master status;+------------------+----------+--------------+------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 342 | | |+------------------+----------+--------------+------------------+ 添加slave账户 12GRANT REPLICATION SLAVE ON *.* to 'slave'@'%' identified by 'reader';FLUSH PRIVILEGES; MariaDB SLAVE没有sql导入的情况123456789101112131415docker run -d \--restart=always \--name mysql-slave2 \-e TIMEZONE=Asia/Shanghai \-v /data/mariadb-slave:/data/mariadb \-e MYSQL_ROOT_PASSWORD=admin \-e LOG_BIN=mysql-bin \-e BINLOG_FORMAT=MIXED \-e REPLICATION_PASSWORD=admin \-e MASTER_LOG_FILE=mysql-bin.000003 \-e MASTER_LOG_POS=342 \-e MASTER_PORT=3306 \-e MASTER_HOST=172.17.0.2 \-p 3310:3306 \mariadb-slave2:1.0 先用sql文件导入再同步123456789101112131415docker run -d \--restart=always \--name mysql-master \-e TIMEZONE=Asia/Shanghai \-v /data/mariadb-slave:/data/mariadb \-e MYSQL_ROOT_PASSWORD=admin \-e BINLOG_FORMAT=MIXED \-e REPLICATION_PASSWORD=admin \-e DATABASE_FILE=database.sql \-e MASTER_LOG_FILE=mysql-bin.000003 \-e MASTER_LOG_POS=342 \-e MASTER_PORT=3306 \-e MASTER_HOST=172.17.0.2 \-p 3308:3306 \mariadb-slave:1.0 需要把database.sql文件存提前存放在/data/mariadb-slave目录 进入slaver的mariadb 1mysql -uroot -padmin -h 172.17.0.3 设置主库链接 1change master to master_host='172.17.0.2',master_user='slave',master_password='reader',master_log_file='mysql-bin.000003',master_log_pos=342,master_port=3306; 启动从库同步 1start slave; 查看状态 1show slave status\G; 当看到 12Slave_IO_Running: YesSlave_SQL_Running: Yes 则启动成功 ##docker redis 集群（cluster）搭建 顺带完成redis集群,安装依赖 1$ docker pull redis 1$ docker pull ruby 创建redis容器 1、创建redis配置文件（redis-cluster.tmpl） 我在路径/root下创建一个文件夹redis-cluster,在路径/root/redis-cluster下创建一个文件redis-cluster.tmpl，并把以下内容复制过去。 10.0.2.15 //自己的服务器ip 12345678port $&#123;PORT&#125;cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 10.0.2.15cluster-announce-port $&#123;PORT&#125;cluster-announce-bus-port 1$&#123;PORT&#125;appendonly yes 创建自定义network 1$ docker network create redis-net 在/root/redis-cluster下生成conf和data目标，并生成配置信息 12345for port in `seq 6379 6384`; do \ mkdir -p ./$&#123;port&#125;/conf \ &amp;&amp; PORT=$&#123;port&#125; envsubst &lt; ./redis-cluster.tmpl &gt; ./$&#123;port&#125;/conf/redis.conf \ &amp;&amp; mkdir -p ./$&#123;port&#125;/data; \done 创建6个redis容器 1234567for port in `seq 6379 6384`; do \ docker run -d -ti -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; \ -v /root/redis-cluster/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf \ -v /root/redis-cluster/$&#123;port&#125;/data:/data \ --restart always --name redis-$&#123;port&#125; --net redis-net \ --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf; \done 通过启动ruby来实现集群 1234567echo yes | docker run -i --rm --net redis-net ruby sh -c ' \gem install redis \&amp;&amp; wget http://download.redis.io/redis-stable/src/redis-trib.rb \&amp;&amp; ruby redis-trib.rb create --replicas 1 \'"$(for port in `seq 6379 6384`; do \echo -n "$(docker inspect --format '&#123;&#123; (index .NetworkSettings.Networks "redis-net").IPAddress &#125;&#125;' "redis-$&#123;port&#125;")":$&#123;port&#125; ' ' ; \done)"]]></content>
      <categories>
        <category>dev</category>
      </categories>
      <tags>
        <tag>容器 数据库 读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去中心化网络游戏设计]]></title>
    <url>%2F2017%2F12%2F11%2F%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[前言写这篇文章之前,我在想这是属于策划案还是开发框架,最终定位到策划案,希望有更多的游戏设计者能先策划出新的玩法,再来定开发框架.本文所述并未实现过任何代码,也并未用于任何上线产品,纯属概念模型.之所以有这种想法,可能是基于昨晚的一次灵感,以及即将设计的游戏有关. 第一章 去中心化概念其实最简单的去中心化游戏就是单机游戏和局域网游戏,但是本文要讲诉的是mmo网络游戏的去中心化,为什么既然网络化了又要去中心化,这不是矛盾吗.网络游戏有个通病,就是网速影响游戏体验过,这是客户端所直接反映的问题,服务端反应的你不能直接感受到的问题,很难做到全球同服,什么意思呢,就是所有玩家不全是在一台服务器上因为服务器是有瓶颈的,本身计算量很大的情况下,socket能承载同时单服1W人在线就很不错了,像coc这种全球一个服的游戏很少,这种服务器的架构就很复杂,绝大部分网游就是分区,另一个好处就是分区重新开始游戏,可以解决通货膨胀问题.coc玩到满级满王满墙也就没有玩下去的动力了.另一方面,单机游戏比起网游,不具备强交互能力,可玩性,游戏性大打折扣.如果做到既能联网交互,又可以不靠网络来获得体验,由客户端去演算游戏逻辑,极大降低服务端成本,这就是本文想探讨的去中心化的游戏.像王者荣耀这样的moba游戏已经很接近本文所说的功能了,但是还是有所区别.至于什么区别读完本文可能有个大致了解.本文要探讨的不是moba,也不是rpg,亦或是slg这些类型,而是总的游戏设计方法.去中心化,没有中心服务器,可以是弱联网,亦或是强联网,核心是有各自客户端或是区域链来演算游戏的逻辑,然而还是有一处中心化得服务器为大家来解决统一数据问题,例如物品交易,这点类似于比特币 第二章 比特币模型我大概简单的描述一下比特币,这也是去中心化的基石.比特币是一种符合某种算法结果的数字货币,什么意思呢,比如在某一个坐标区域,坐标值代入md5公式,能得到一个符合”x01”字符串的值,那么就认为你找到一枚数字货币,而且这个货币还能定义下一个坐标区域,也就是说,当前区域总的货币数量是一定的,没有挖掘完之前,也无法开采下一个坐标区域.比特币的函数要比我所述的复杂,但基本上是这个意思,算法是公开的,能得到的货币是有限的,一旦挖掘到货币就与中心服确认,并且获得所有权.那如果把这个模型改造一下.游戏币是从boss掉落的,或者生产制作的.或者任务获得的,假设boss,制作工具,任务都有一个gid,全局唯一ID,而且产生的作者也有个唯一uid,再加上创造出来的时间戳time,那我们可以拿着这些数据,到服务器去鉴别真伪,中心服务器会保存一个私钥,给gid+uid+time+key签名,这个货币就有一个串值,如果同一个uid复制多个货币,因为签名一样,也会被认为是一个货币而删掉其他,如果发生交易,那么这个货币还要一个交易序列,给gid+uid+time+trade+key签名会成为新的串值,而中心服会保存所有货币的最新值,也就是说两个玩家拥有了同样的货币,看他们串值是否是最新的,那么鉴别为旧版货币的就是假币.如果都修改成同一串值,那么看交易序列的最后拥有者是谁,谁就是真币.这是我想到的数字货币模型,但是如果作为游戏币,每一个货币都要保存很多值,所以我更倾向于付费可交易货币做这种去中心化的真伪模型,比如银票.而不能交易的游戏币还是只是简单的数字. 第三章 装备模型上述所说比特币模型,数字货币模型,如果直接引用到装备模型,完全可以像数字货币一样,做到去中心化的真伪模型,玩家获得一件装备,属于未鉴定状态,需要向中心服鉴别真伪,如果为伪,那装备没有加成的属性.我们还需要处理的一件事情是防止玩家直接对真实装备改值,这需要第一,配置表的时候就生产一个验证,是否是改过配置表,第二,生成装备的时候要要把属性加入到串码算法中.玩家战斗时检测装备正确性,因为是客户端自己验算,所以也不会对服务端产生压力,目前客户端性能越来越强大,对于简单的演算还是可以接受的. 第四章 函数逻辑模型所有的演算,逻辑都在客户端,或者说区域链服,可以把区域链服理解为几个人组局域网后其中一个人为主机的概念,那么客户端也可能对函数进行作弊,这种无法从任何算法上解决,但去中心化还有种思路是,可以认同50%以上的逻辑为正确的逻辑,也就是说假如我5个人联网,有3个人结果一致,就按这3个人的逻辑,如果5个人结果都不一致,那么此次验证失败,那么只要大部分的人保持正确心态,可以容忍少部分人作弊,也只能是自己单机演算作弊,假如多数人作弊的情况下,大环境下也可以认可是公平的.只是作为运营的我们收入大大折扣了,所以要防止这种事情发生.另外,如果防止单机作弊,我的想法是每次函数堆栈(重要的战斗算法)要保存起来参数,返回值,这些,传给服务器做一个校正,是否真伪,如果作弊可以纳入非诚信玩家,并给与一定惩罚 第五章 其他中心化包含的内容有些内容是无法去中心化的,比如全局装备鉴别,货币鉴别,装备交易,玩家排行榜,世界聊天,世界地图等这些本身就是要做中心化的交互,所以这里不予讨论,这里只是把战斗,组队,装备掉落这些耗时的主要逻辑在客户端来演算,来增加体验和性能. 后记说了这么多,其实还并没有实现一个基于这个想法的游戏.如果把RPG设计成去中心化,要解决大地图的问题,如果大地图还是中心服那就没有意义,还是需要处理很多逻辑,所以这个适合跑大地图,进副本战斗和回合制战斗的RPG游戏.如果把MOBA设计成去中心化,那其实就是当年的魔兽,星际,只是主机不是一台,而是多台,以大多数人的演算为准,个人感觉,意义也不大,直接做局域网的游戏就可以了,只是加个中心交互,如果用来做SLG,感觉还是不错的,试想一下三国志并不是你一个人在攻城略地,有没有很刺激.如果做其他的小地图副本游戏也是可以的.当然这个设计也是有弊端的,你需要容忍数据不能像ARGP那样及时同步,因为你无法保证组队的5个人每个人的网络都很好,万一有个别人卡住,要么踢掉他,要么等他回来的验算结果.其他的弊端暂未想到,欢迎一起来讨论]]></content>
      <categories>
        <category>dev</category>
      </categories>
      <tags>
        <tag>游戏设计 去中心化 区域链 bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Amazing hexo]]></title>
    <url>%2F2015%2F12%2F03%2FAmazing-hexo%2F</url>
    <content type="text"><![CDATA[ForewordI have been looking for such a blog, strong self-confidence like WordPress.And Spending dollars to buy the domain name and server space is prerequisite.I never thought that a free and almost unlimited freedom blog exist.Hexo just like this. A fast, simple &amp; powerful blog. I did not hesitate to try it.So far so amazing. Quick StartFirstLet’s introduce how to set up hexo.Please Download nodejs from http://nodejs.org.I get node-v4.2.2-x64.msi.then double click to install nodejs.Keep the default configuration to direct the installation. 1$ npm install -g hexo-cli Setup your blog.make a name in the computer called “YOU NAME” folder (for example, I make dir in D:\workspace\OSGDreamWorks\ibunnyteam.github.io).then open this folder, run the following command. 1234$ hexo init[info] Copying data[info] You are almost done! Don't forget to run `npm install` before you start blogging with Hexo! Hexo will automatically create a file in the target folder that website require.Then follow the prompts to run npm install (in “YOU NAME” folder). 1$ npm install then you can get the node_modules.All work will be done automatically by nodejs. Start the serverRun the following command (in “YOU NAME” folder). 12$ hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. Then you can open the local blog. easy, all right! Create a new postOpen a new command-line window, execute the following command 12$ hexo new "My New Post"[info] File created at d:\Hexo\source\_posts\My-New-Post.md Refresh http://localhost:4000/，you can see the “My New Post”。 Generate static files执行下面的命令，将markdown文件生成静态网页。 1$ hexo generate After this command is executed, it will be generating a series of html, css and other documents in public directory. Upload the blogNow you only have established a local blog.How others see your blog.You need github. Also amazing project.your can know every thing in github.comhttps://github.com/ continueDeployed to the former Github need to configure _config.yml file, first locate the following content. 1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: Changed to: 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:ibunnyteam/ibunnyteam.github.io.git branch: master NOTE1:Repository: SSH form must be url (git@github.com: ibunnyteam / ibunnyteam.github.io.git), but can not be HTTPS form url (https://github.com/ibunnyteam/ibunnyteam.github.io. git), otherwise an error:You need named the repository YOU_GITHUB_ACCOUNT.github.io then you can open the github static web.12$ hexo deploy[info] Start deploying: github Use SSH url, if the computer is not an open SSH port will cause the deployment to fail. 12345[error] https://github.com/ibunnyteam/ibunnyteam.github.io is not a valid repositor URL!fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. NOTE2：If you are making a project website, then you need to branch to gh-pages. Lastyou can make a domain name with the github static web. The short command for hexo: new blog1$ hexo n generate1$ hexo g upload1$ hexo d Have fun]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo github nodjs</tag>
      </tags>
  </entry>
</search>
